badBody = """{"blocks":[{"key":"6temp","text":"I've been finding a strange behaviour of log functions in C++ and numpy about the behaviour of log function handling complex infinite numbers. Specifically, log(inf + inf * 1j) equals (inf + 0.785398j) when I expect it to be (inf + nan * 1j).","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":41,"length":3,"style":"CODE"},{"offset":95,"length":3,"style":"CODE"},{"offset":157,"length":19,"style":"CODE"},{"offset":184,"length":17,"style":"CODE"},{"offset":225,"length":16,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3srkv","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"adbci","text":"When taking the log of a complex number, the real part is the log of the absolute value of the input and the imaginary part is the phase of the input. Returning 0.785398 as the imaginary part of log(inf + inf * 1j) means it assumes the infs in the real and the imaginary part have the same length. This assumption does not seem to be consistent with other calculation, for example, inf - inf == nan, inf / inf == nan which assumes 2 infs do not necessarily have the same values.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":195,"length":19,"style":"CODE"},{"offset":236,"length":3,"style":"CODE"},{"offset":382,"length":16,"style":"CODE"},{"offset":400,"length":16,"style":"CODE"},{"offset":433,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"2vs7c","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7cl2r","text":"Why is the assumption for log(inf + inf * 1j) different?","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":26,"length":19,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"1o3vs","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97sp2","text":"Reproducing C++ code:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ba54k","text":"#include <complex>
#include <limits>
#include <iostream>
int main() {
    double inf = std::numeric_limits<double>::infinity();
    std::complex<double> b(inf, inf);
    std::complex<double> c = std::log(b);
    std::cout << c << "\n";
}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":237,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"fdhll","text":"Reproducing Python code (numpy):","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"kqfc","text":"import numpy as np

a = complex(float('inf'), float('inf'))
print(np.log(a))","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":76,"style":"CODE"}],"entityRanges":[],"data":{}}],"entityMap":{}}"""

goodBody = """{"blocks":[{"key":"6o4ue","text":"I've been finding a strange behaviour of log functions in C++ and numpy about the behaviour of log function handling complex infinite numbers. Specifically, log(inf + inf * 1j) equals (inf + 0.785398j) when I expect it to be (inf + nan * 1j).","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":41,"length":3,"style":"CODE"},{"offset":95,"length":3,"style":"CODE"},{"offset":157,"length":19,"style":"CODE"},{"offset":184,"length":17,"style":"CODE"},{"offset":225,"length":16,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"5mkb3","text":"When taking the log of a complex number, the real part is the log of the absolute value of the input and the imaginary part is the phase of the input. Returning 0.785398 as the imaginary part of log(inf + inf * 1j) means it assumes the infs in the real and the imaginary part have the same length. This assumption does not seem to be consistent with other calculation, for example, inf - inf == nan, inf / inf == nan which assumes 2 infs do not necessarily have the same values.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":195,"length":19,"style":"CODE"},{"offset":236,"length":3,"style":"CODE"},{"offset":382,"length":16,"style":"CODE"},{"offset":400,"length":16,"style":"CODE"},{"offset":433,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"2175o","text":"Why is the assumption for log(inf + inf * 1j) different?","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":26,"length":19,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3c0io","text":"Reproducing C++ code:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3rprk","text":"#include <complex>\n#include <limits>\n#include <iostream>\nint main() {\n    double inf = std::numeric_limits<double>::infinity();\n    std::complex<double> b(inf, inf);\n    std::complex<double> c = std::log(b);\n    std::cout << c << \"\\n\";\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":237,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3i79a","text":"Reproducing Python code (numpy):","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"819tl","text":"import numpy as np\n\na = complex(float('inf'), float('inf'))\nprint(np.log(a))","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":76,"style":"CODE"}],"entityRanges":[],"data":{}}],"entityMap":{}}"""

for idx in range(0, 100):
  if (goodBody[idx] != badBody[idx]):
    print(goodBody[idx])
    print(badBody[idx])
    print(idx)
    print('----------------------')
